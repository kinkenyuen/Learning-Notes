# 目录
 * [关于线程编程](#关于线程编程)
 * [线程是什么？](#线程是什么)
 * [线程术语](#线程术语)
 * [线程的替代方案](#线程的替代方案)
 * [Threading Support](#threading-support)
    * [Threading Packages](#threading-packages)
    * [Run Loops](#run-loops)
    * [Synchronization Tools (同步工具)](#synchronization-tools-同步工具)
    * [Inter-thread Communication(跨进程通信)](#inter-thread-communication跨进程通信)
 * [设计技巧](#设计技巧)
    * [避免显式地创建线程](#避免显式地创建线程)
    * [保持线程忙碌](#保持线程忙碌)
    * [避免共享数据结构](#避免共享数据结构)
    * [线程和用户界面](#线程和用户界面)
    * [注意线程在退出时的行为](#注意线程在退出时的行为)
    * [处理异常](#处理异常)
    * [干净地终止线程](#干净地终止线程)
    * [库中的线程安全](#库中的线程安全)
 * [源文档](#源文档)

# 关于线程编程

多年来，计算机的最大性能在很大程度上受限于位于计算机核心的**单个微处理器**的速度。然而，随着单个处理器的速度开始达到它们的实际极限，芯片制造商转而采用**多核设计**，使计算机有机会同时执行多个任务。

OSX/iOS在任何时候都可以利用这些核心来执行任务，我们自己的应用程序也可以通过线程来使用这些核心。

# 线程是什么？

线程是在应用程序中实现**多条执行路径**的一种相对轻量级的方法。在系统级，程序并行运行，系统根据每个程序的需要和其他程序的需要给每个程序分配执行时间。然而，**在每个程序内部都存在一个或多个执行线程**，这些线程可用于同时或几乎同时执行不同的任务。系统本身实际上管理这些执行线程，将它们调度到可用的核心上运行，并在需要时立刻中断它们，以允许其他线程运行。

从技术角度看，线程是管理代码执行所需的内核级和应用程序级数据结构的组合。（线程是数据结构组合）

内核级结构协调**事件调度到线程上**以及**线程在一个可用CPU核心上的抢占式调度**。

应用程序级结构包括用于存储函数调用的调用堆栈以及应用程序管理和操作线程属性和状态所需的结构。

在非并发应用程序中，只有一个执行线程。该线程以应用程序的main函数开始，并逐步执行不同的方法或函数，以实现应用程序的整体行为，直至函数退出。

相比之下，支持并发的应用程序从一个线程开始，并根据需要添加更多线程来创建额外的执行路径。每个新路径都有自己的自定义启动例程，独立于应用程序主例程中的代码运行。

应用程序支持多线程的两个优势：

1. 多线程可以提高应用程序的响应能力
2. 多线程可以提高应用程序在多核系统上的实时性能。

如果您的应用程序只有一个线程，那么这个线程必须完成所有的工作。它必须响应事件，更新应用程序的窗口，并执行实现应用程序行为所需的所有计算。只有一个线程的问题是它一次只能做一件事。那么当你的计算需要很长时间才能完成时会发生什么呢?当你的代码忙于计算它需要的值时，你的应用程序停止响应用户事件和更新它的窗口。如果这种行为持续的时间足够长，用户可能会认为您的应用程序挂起，并试图强制退出它。但是，如果将自定义计算移到单独的线程上，应用程序的主线程就可以更及时地响应用户交互。

当然，线程并不是解决应用程序性能问题的万能药。线程提供的好处带来了潜在的问题。在应用程序中有多条执行路径可能会给代码增加相当多的复杂性。每个线程必须与其他线程协调其操作，以防止破坏应用程序的状态信息。因为单个应用程序中的线程共享相同的内存空间，所以它们可以访问所有相同的数据结构。如果两个线程试图同时操作同一数据结构，一个线程可能会以破坏结果数据结构的方式覆盖另一个线程的更改。即使有了适当的保护，您仍然必须注意编译器优化，以免在代码中引入微妙的(或不那么微妙的)错误。

# 线程术语
在深入讨论线程及其支持技术之前，有必要定义一些基本术语。

如果您熟悉UNIX系统，您可能会发现本文对“任务”一词的使用有所不同。在UNIX系统上，术语“任务”有时用来指正在运行的进程。

本文采用的术语:

* 术语线程是指代码执行的单独路径
* 术语进程是指正在运行的可指向文件，它可以包含多个线程
* 术语任务是用来指需要执行的工作的抽象概念

# 线程的替代方案

自己创建线程的一个问题是它们会给代码增加不确定性。线程是在应用程序中支持并发性的一种相对底层和复杂的方法。如果您不能完全理解设计选择的含义，则很容易遇到同步或计时问题，其严重程度可能从细微的行为变化到应用程序崩溃和用户数据损坏。

另一个需要考虑的因素是您是否需要线程或并发性。线程解决了如何在同一个进程中并发地执行多个代码路径的特定问题。但是，在某些情况下，您所做的工作量并不保证并发性。线程给进程带来了巨大的开销，包括内存消耗和CPU时间。您可能会发现这个开销对于预期的任务来说太大了，或者其他选项更容易实现。

表1-1列出了线程的一些替代方案。这个表包含了线程的替换技术(如Operation对象和GCD)，以及针对有效地使用已有的单个线程的替代技术。

表1-1 线程替代技术

| Technology | Description  |
|---|---|
|**Operation对象**| Operation对象是通常在辅助线程上执行的任务的包装器。这个包装器隐藏了执行任务的线程管理方面，使您可以将精力集中在任务本身上。通常将这些对象与操作队列对象结合使用，操作队列对象实际管理Operation对象在一个或多个线程上的执行。|
|**Grand Central Dispatch (GCD)**|GCD是线程的另一种替代方案，它使您可以专注于需要执行的任务，而不是线程管理。使用GCD，您可以定义想要执行的任务，并将其添加到工作队列中，该工作队列在适当的线程上处理任务的调度。工作队列考虑到可用内核的数量和当前负载，以便比使用线程更有效地执行任务。|
|**Idle-time notifications**|对于相对较短且优先级很低的任务，空闲时间通知可以让您在应用程序不那么忙的时候执行任务。Cocoa通过NSNotificationQueue对象提供了对空闲时间通知的支持。要请求一个空闲时间通知，使用NSPostWhenIdle选项post一个通知到默认的NSNotificationQueue对象。队列延迟**通知对象**的传递，直到runloop空闲。|
|**Asynchronous functions**|系统接口包括许多为您提供**自动并发性的异步函数**。这些api会使用系统守护进程和进程，或者创建自定义线程来执行它们的任务并将结果返回给您。(实际的实现是不相关的，因为它与代码是分离的。)在设计应用程序时，寻找提供异步行为的函数，并考虑使用它们，**而不是在自定义线程上使用等价的同步函数**。 |
|**Timers**|您可以在应用程序的主线程上使用计时器来执行周期性任务，这些任务非常琐碎，不需要线程，但仍然需要定期提供服务。 |
|**Separate processes**|尽管比线程更重量级，但在任务与应用程序仅略微相关的情况下，创建一个单独的进程可能是有用的。如果任务需要大量内存，或者必须使用根权限执行，则可以使用进程。例如，您可能使用64位服务器进程来计算大量数据集，而您的32位应用程序将结果显示给用户。**当使用fork函数启动单独的进程时，您必须始终在调用fork之后调用exec或类似的函数。依赖于Core Foundation、Cocoa或Core Data框架(显式或隐式)的应用程序必须后续调用exec函数，否则这些框架可能会行为不当。**|

# Threading Support

如果你有使用线程的代码，OS X和iOS提供了几种在你的应用程序中创建线程的技术。此外，这两个系统还提供了管理和同步需要在这些线程上完成的工作的支持。以下几节描述了在OS X和iOS中使用线程时需要注意的一些关键技术。

## Threading Packages

尽管线程的底层实现机制是Mach线程，但您很少(如果有的话)使用Mach级别的线程。相反，您通常使用更方便的POSIX API或其衍生物之一。

>The Mach implementation does provide the basic features of all threads, however, including the preemptive execution model and the ability to schedule threads so they are independent of each other.

Mach的实现确实提供了所有线程的基本特性，但是，包括抢占执行模型和调度线程的能力，使它们彼此独立。

表1-2列出了应用程序中可以使用的线程技术。

表1-2 线程技术

| Technology | Description  |
|---|---|
| **Cocoa threads**| Cocoa使用NSThread类来实现线程。Cocoa还在NSObject上提供了生成新线程和在已经运行的线程上执行代码的方法。|
|**POSIX threads**|POSIX线程提供了一个基于c的接口来创建线程。如果您不是在编写Cocoa应用程序，那么这是创建线程的最佳选择。POSIX接口使用起来相对简单，并为配置线程提供了充足的灵活性。|
|**Multiprocessing Services**|多处理服务是一个遗留的基于c的接口，用于从旧版本的Mac OS过渡过来的应用程序。该技术仅在OS X中可用，任何新开发都应避免使用。相反，你应该使用NSThread类或POSIX线程。|

在应用层上，所有线程的行为基本上与其他平台上相同。启动一个线程后，该线程以三种主要状态之一运行:**运行、就绪或阻塞**。如果一个线程当前没有运行，它要么被阻塞并等待输入，要么已经准备好运行，但还没有计划这样做。线程继续在这些状态之间来回移动，直到它最终**退出**并转到**终止**状态。

当您创建一个新的线程时，您必须**为该线程指定一个入口点函数**(或者Cocoa线程的入口点方法)。这个入口点函数构成了要在线程上运行的代码。当函数返回时，或者当您显式地终止线程时，线程将永久停止并被系统回收。由于创建线程在内存和时间方面相对昂贵，因此建议您的入口点函数执行大量工作或设置runloop，以允许重复执行工作。

## Run Loops

runloop是用于**管理异步到达线程的事件**的对象。runloop的工作原理是监视线程的一个或多个事件源。当**事件到达**时，系统**唤醒线程**并将事件分派给runloop，然后runloop将事件分派给您指定的处理程序。如果**没有事件**存在并准备处理，则runloop将线程置于**睡眠状态**。

您不需要对创建的任何线程使用runloop，但这样做可以为用户提供更好的体验。runloop可以创建使用最少资源的常驻线程。因为runloop在无事可做时让线程进入睡眠状态，所以它**消除了轮询(轮询会浪费CPU周期，并阻止处理器本身进入睡眠状态)的需要**，从而节省电力。

要配置一个runloop，您需要做的就是启动线程，获取对runloop对象的引用，设置事件处理程序，并告诉runloop开始运行。**OS X / iOS会自动为您处理主线程runloop的配置。但是，如果计划创建长期存在的辅助线程，则必须自己为这些线程配置运行循环。**

## Synchronization Tools (同步工具)

线程编程的一个危害是多个线程之间的资源争用。如果多个线程试图同时使用或修改同一资源，就会出现问题。缓解这个问题的一种方法是完全**消除共享资源**，并确保每个线程都有自己要操作的独特资源集。当维护完全独立的资源不是一个选项时，您可能必须**使用锁、条件、原子操作和其他技术来同步对资源的访问**。

**锁**提供一次只能由一个线程执行的代码提供了蛮力形式的保护。最常见的锁类型是互斥锁。当一个线程试图获取当前被另一个线程持有的互斥锁时，它会阻塞，直到该锁被另一个线程释放。一些系统框架提供了对互斥锁的支持，尽管它们都基于相同的底层技术。此外，Cocoa还提供了互斥锁的几种变体，以支持不同类型的行为，比如递归。

除了锁之外，系统还提供**条件**支持，以确保应用程序中任务的正确排序。条件充当看门人，阻塞给定的线程，直到它所代表的条件变为真为止。当这种情况发生时，条件释放线程并允许它继续。POSIX层和Foundation框架都为条件提供了直接支持。(如果您使用Operation对象，您可以配置Operation对象之间的依赖关系来排序任务的执行，这与条件提供的行为非常相似。)

虽然锁和条件在并发设计中非常常见，但**原子操作**是保护和同步数据访问的另一种方式。在可以对标量数据类型执行数学或逻辑操作的情况下，原子操作提供了锁的轻量级替代方案。原子操作使用特殊的硬件指令来确保在其他线程有机会访问变量之前完成对变量的修改。

## Inter-thread Communication(跨进程通信)

尽管一个好的设计可以减少所需的通信量，但在某些情况下，线程之间的通信是必要的。(线程的工作是为您的应用程序做工作，但如果该工作的结果从未被使用，它有什么好处?)**线程可能需要处理新的工作请求或将其进度报告给应用程序的主线程**。在这些情况下，您需要一种从一个线程向另一个线程获取信息的方法。幸运的是，线程共享相同的进程空间这一事实意味着您有许多通信选项。

线程之间有许多通信方式，每种方式都有自己的优缺点。
> Configuring Thread-Local Storage lists the most common communication mechanisms you can use in OS X. (With the exception of message queues and Cocoa distributed objects, these technologies are also available in iOS.) 

本表中的技术是按照复杂性的增加顺序列出的。

表1-3  通信机制

| Mechanism | Description |
|---|---|
|**Direct messaging**| Cocoa应用程序支持在其他线程上直接执行选择器。这个功能意味着一个线程可以在任何其他线程上执行一个方法。由于它们是在目标线程的上下文中执行的，因此以这种方式发送的消息将自动在该目标线程上序列化。- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(nullable id)arg waitUntilDone:(BOOL)wait|
|**Global variables, shared memory, and objects**|在两个线程之间通信信息的另一种简单方法是使用全局变量、共享对象或共享内存块。尽管共享变量快速而简单，但它们也比直接消息传递更脆弱。必须用锁或其他同步机制小心地保护共享变量，以确保代码的正确性。如果不这样做，可能会导致竞争条件、损坏数据或崩溃。|
|**Conditions**|条件是一种同步工具，您可以使用它来控制线程何时执行代码的特定部分。你可以把条件想象成看门人，只在条件满足时才让线程运行。|
|**Run loop sources**| 自定义run loop源是用于在线程上接收特定于应用程序的消息的源。因为它们是事件驱动的，所以run loop源会在线程无事可做时自动让线程休眠，这提高了线程的效率。|
|**Ports and sockets**|基于端口的通信是两个线程之间通信的一种更复杂的方式，但它也是一种非常可靠的技术。更重要的是，**端口和套接字可以用来与外部实体(如其他流程和服务)通信**。为了提高效率，端口是使用runloop源实现的，因此当端口上没有等待的数据时，线程将休眠。|
|**Message queues**|传统的多处理服务定义了先进先出(FIFO)队列抽象，用于管理传入和传出的数据。尽管消息队列简单方便，但它们的效率不如其他一些通信技术。|
|**Cocoa distributed objects**|分布式对象是一种Cocoa技术，它提供了基于端口的通信的高级实现。尽管可以将此技术用于线程间通信，但由于它会带来大量开销，因此非常不鼓励这样做。分布式对象更适合于与其他进程通信，在这些进程之间传输的开销已经很高了。|

# 设计技巧

下面几节提供了一些指导方针，帮助您以一种确保代码正确性的方式实现线程。其中一些指导原则还提供了一些技巧，帮助您使用自己的线程代码实现更好的性能。与任何性能技巧一样，您应该总是在更改代码之前、期间和之后收集相关的性能统计数据。

## 避免显式地创建线程

手动编写线程创建代码是一件乏味的事情，而且可能容易出错，所以您应该尽可能避免这样做。OS X和iOS通过其他api提供了对并发的隐式支持。**与其自己创建线程，不如考虑使用异步api、GCD或Operation对象来完成这项工作**。这些技术在幕后为您完成与线程相关的工作，并且保证能够正确地完成这些工作。此外，**通过根据当前系统负载调整活动线程的数量，GCD和Operation对象等技术被设计成比您自己的代码更有效地管理线程**。

## 保持线程忙碌

如果您决定手动创建和管理线程，请记住线程会消耗宝贵的系统资源。您应该尽最大努力确保您分配给线程的任何任务都是合理的长久和高效的。与此同时，您不应该担忧终止大部分时间处于空闲状态的线程。线程使用大量的内存，其中一些是连续的，因此释放空闲线程不仅有助于减少应用程序的内存占用，还可以释放更多的物理内存供其他系统进程使用。

## 避免共享数据结构

避免与线程相关的资源冲突的最简单和最简单的方法是给程序中的每个线程提供它自己需要的任何数据的副本。当最小化线程间通信以及资源竞争后，多线程并行的代码性能好。

创建一个多线程应用程序是困难的。即使您非常小心并在代码中所有正确的边界处锁定共享数据结构，您的代码在语义上仍然可能是不安全的。

>For example, your code could run into problems if it expected shared data structures to be modified in a specific order. 

>Changing your code to a transaction-based model to compensate could subsequently negate the performance advantage of having multiple threads. 

>Eliminating the resource contention in the first place often results in a simpler design with excellent performance.

## 线程和用户界面

如果您的应用程序有一个图形用户界面，建议您从应用程序的主线程接收与用户相关的事件并启动界面更新。这种方法有助于避免与处理用户事件和绘制窗口内容相关的同步问题。一些框架，如Cocoa，通常需要这种行为，但即使对于那些不需要这种行为的框架，将这种行为保留在主线面上也可以简化管理用户界面的逻辑。

有几个值得注意的例外情况，从其他线程执行图形操作是有利的。例如，您可以使用辅助线程来创建和处理图片，并执行其他与图片相关的计算。为这些操作使用辅助线程可以大大提高性能。如果你不确定某个特定的图形操作，可以考虑在主线程操作。

## 注意线程在退出时的行为

进程一直运行，直到所有`non-detached`线程都退出为止。默认情况下，只有应用程序的主线程被创建为`non-detached`的，但您也可以通过这种方式创建其他线程。当用户退出应用程序时，立即终止所有`detached `线程通常被认为是合适的行为，因为`detached `线程所做的工作被认为是可选的。但是，如果你的应用程序正在使用后台线程来将数据保存到磁盘或做其他重要的工作，那么你可能希望将这些线程创建为`non-detached`的，以防止在应用程序退出时丢失数据。

将线程创建为`non-detached`的(`also known as joinable`)需要额外的工作。因为大多数高级线程技术在默认情况下不会创建`joinable`的线程，所以您可能必须使用POSIX API来创建线程。此外，您必须在应用程序的**主线程**中添加代码，以便在`non-detached`线程最终退出时连接它们。

如果你正在编写一个Cocoa应用程序，你也可以使用`applicationShouldTerminate:`delegate方法来延迟应用程序的终止，直到以后的时间或完全取消它。当延迟终止时，您的应用程序需要等待，直到任何关键线程完成它们的任务，然后调用`replyToApplicationShouldTerminate:`方法。

## 处理异常

当抛出异常时，异常处理机制依赖于当前调用堆栈来执行任何必要的清理。因为每个线程都有自己的调用堆栈，所以每个线程都负责捕获自己的异常。在次要线程中捕捉异常失败与在主线程中捕捉异常失败是一样的:宿主进程被终止。您不能将未捕获的异常抛出给不同的线程进行处理。

如果您需要通知另一个线程(例如主线程)当前线程中的异常情况，您应该捕获异常并简单地向其他线程发送一条消息，说明发生了什么。根据您的模型和您正在尝试做的事情，捕获异常的线程可以继续处理(如果可能的话)，等待指令，或者直接退出。

>Note: In Cocoa, an NSException object is a self-contained object that can be passed from thread to thread once it has been caught.

## 干净地终止线程

线程退出的最好方法是自然地让它到达它的主入口点例程的末尾。尽管有一些函数可以立即终止线程，但这些函数只能作为最后的手段使用。在一个线程到达它的自然端点之前终止它，可以防止线程在它自己之后进行清理。**如果线程分配了内存、打开了文件或获得了其他类型的资源，那么您的代码可能无法回收这些资源，从而导致内存泄漏或其他潜在问题。**

## 库中的线程安全

虽然应用程序开发人员可以控制应用程序是否使用多个线程执行，但库开发人员不能。在开发库时，您必须假定调用应用程序是多线程的，或者可以在任何时候切换到多线程。因此，您应该总是对代码的关键部分使用锁。

对于库开发人员来说，只在应用程序变成多线程时才创建锁是不明智的。如果需要在某个时候锁定代码，请在使用库的早期创建锁对象，最好是在某种显式调用中初始化库。尽管您也可以使用静态库初始化函数来创建此类锁，但只有在没有其他方法时才尝试这样做。执行初始化函数会增加加载库所需的时间，并可能对性能产生不利影响。

> Note: Always remember to balance calls to lock and unlock a mutex lock within your library. You should also remember to lock library data structures rather than rely on the calling code to provide a thread-safe environment.

如果你正在开发一个Cocoa库，你可以注册NSWillBecomeMultiThreadedNotification的观察者，如果你想在应用变成多线程的时候得到通知的话。但是，您不应该依赖于接收这个通知，因为它可能会在调用库代码之前被分派。

# 源文档

[About Threaded Programming](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/AboutThreads/AboutThreads.html#//apple_ref/doc/uid/10000057i-CH6-SW2)

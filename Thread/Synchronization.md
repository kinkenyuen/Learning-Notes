# 同步

一个应用程序中存在多个线程，这就可能出现从多个执行线程安全访问资源的问题。两个修改同一资源的线程可能会以意想不到的方式相互干扰。例如，一个线程可能会覆盖另一个线程的更改，或将应用程序置于未知且可能无效的状态。如果幸运的话，损坏的资源可能会导致明显的性能问题或崩溃，这些问题比较容易跟踪和修复。但是，如果不幸的话，损坏可能会导致一些微妙的错误，这些错误直到很久以后才显现出来，或者这些错误可能需要重写底层基本代码。

说到线程安全，一个好的设计是你拥有的最好的保护。**避免共享资源和最小化线程之间的交互可以减少线程之间相互干扰的可能性**。然而，一个完全无干扰的设计并不总是可能的。在线程必须进行交互的情况下，**您需要使用同步工具来确保它们在交互时能够安全地进行**。

OS X和iOS提供了大量的同步工具供您使用，从提供**互斥访问**的工具到那些在您的应用程序中**正确排序事件**的工具。下面几节将描述这些工具以及如何在代码中使用它们来影响对程序资源的安全访问。

# 同步工具

为了防止不同的线程意外地更改数据，您可以将应用程序设计为不存在同步问题，也可以使用同步工具。尽管完全避免同步问题是可取的，但这并不总是可能的。下面的部分描述了您可以使用的同步工具的基本类别。

## 原子操作

原子操作是对简单数据类型进行同步的一种简单形式。原子操作的优点是它们不会阻塞竞争线程。对于简单的操作，例如递增一个计数器变量，这比使用锁性能好得多。

OS X和iOS包括大量的操作，用于对32位和64位值执行基本的数学和逻辑操作。这些操作包括比较和交换操作、测试和设置操作以及测试和清除操作的原子版本。有关更多原子操作可查看`/usr/include/libkern/OSAtomic.h`头文件或查看[atomic](https://developer.apple.com/library/archive/documentation/System/Conceptual/ManPages_iPhoneOS/man3/atomic.3.html#//apple_ref/doc/man/3/atomic)介绍。

## 内存屏障和易失性变量（Memory Barriers and Volatile Variables）

为了达到最佳性能，编译器经常重新排列汇编级指令，以使处理器的指令管道尽可能满。作为优化的一部分，当编译器认为这样做不会产生不正确的数据时，它可能会对访问主存的指令重新排序。不幸的是，编译器并不总是能够检测到所有与内存相关的操作。如果看似独立的变量实际上相互影响，则编译器优化可能会以错误的顺序更新这些变量，从而产生可能不正确的结果。

内存屏障是一种非阻塞的同步工具，用于确保内存操作以正确的顺序进行。内存屏障的作用就像一个栅栏，使处理器先完成栅栏前面的加载、存储操作，再完成栅栏之后的加载、存储操作。内存屏障通常用于确保一个线程(但对另一个线程可见)的内存操作总是按照预期的顺序进行。在这种情况下，缺少内存屏障可能会让其他线程看到看似不可能的结果。（要查看案例，参见维基百科[Memory barrier](https://en.wikipedia.org/wiki/Memory_barrier)）要使用内存屏障，只需在代码中的适当位置调用OSMemoryBarrier函数。

易失性变量对单个变量应用另一种类型的内存约束。编译器通常通过将变量的值装入寄存器来优化代码。对于局部变量，这通常不是问题。但是，如果变量在另一个线程中是可见的，这样的优化可能会防止其他线程注意到对它的任何更改。将volatile关键字应用于变量，强制编译器在每次使用该变量时从内存加载该变量。如果一个变量的值可以在任何时候被编译器无法检测到的外部源更改，则可以将其声明为volatile。

因为内存屏障和volatile变量都减少了编译器可以执行的优化次数，所以应该尽量少使用它们，并且只在需要的地方使用，以确保正确性。有关使用内存屏障的信息，请参阅[OSMemoryBarrier](https://developer.apple.com/library/archive/documentation/System/Conceptual/ManPages_iPhoneOS/man3/OSMemoryBarrier.3.html#//apple_ref/doc/man/3/OSMemoryBarrier)。

## 锁

**锁是最常用的同步工具之一。您可以使用锁来保护代码的关键部分，这是一段每次只允许一个线程访问的代码。例如，一个临界区可能操作一个特定的数据结构，或者使用一些一次最多支持一个客户端的资源。通过在这个部分周围放置一个锁，可以排除其他线程进行可能影响代码正确性的更改**。

表4-1列出了程序员常用的一些锁。OS X和iOS提供了大多数锁类型的实现，但不是全部。对于不支持的锁类型，描述列解释了为什么这些锁不能直接在平台上实现。

表4-1 锁类型

| Lock                            | Description                                                  |
| ------------------------------- | ------------------------------------------------------------ |
| Mutex(互斥锁)                   | 互斥锁充当资源周围的保护屏障。互斥锁是一种信号量，每次只允许访问一个线程。如果一个互斥锁正在使用中，而另一个线程试图获取它，那么该线程将阻塞，直到互斥锁被其原始持有者释放。如果多个线程竞争同一个互斥锁，那么一次只允许一个线程访问它。 |
| Recursive lock（递归锁）        | 递归锁是互斥锁的变体。递归锁允许单个线程在释放锁之前多次获取锁。其他线程保持阻塞状态，直到锁的所有者释放它获得锁的相同次数的锁。递归锁主要在递归迭代期间使用，但也可以在多个方法各自需要分别获取锁的情况下使用。 |
| Read-write lock(读写锁)         | 读写锁也称为共享排他锁。这种类型的锁通常用于大规模操作，如果经常读取受保护的数据结构，并且只偶尔修改，则可以显著提高性能。正常运行时，多个读取者可以同时访问该数据结构。但是，当一个线程想要写这个结构时，它就会阻塞，直到所有的读取器释放锁，这时它就可以获得锁并更新这个结构。当写线程等待锁时，新的读线程会阻塞，直到写线程完成。系统仅支持使用POSIX线程使用读写锁。更多使用锁的相关信息，参见[pthread](https://developer.apple.com/library/archive/documentation/System/Conceptual/ManPages_iPhoneOS/man3/pthread.3.html#//apple_ref/doc/man/3/pthread) |
| Distributed lock(分布式锁)      | 分布式锁在进程级别上提供互斥访问。与真正的互斥锁不同，分布式锁不会阻塞进程或阻止进程运行。它只是报告锁何时繁忙，并让进程决定如何继续。 |
| Spin lock(自旋锁)               | 自旋锁反复轮询其锁条件，直到该条件为真。自旋锁最常用于多处理器系统，在这些系统中，锁的预期等待时间很短。在这些情况下，轮询通常比阻塞线程更有效，阻塞线程涉及上下文切换和线程数据结构的更新。由于旋转锁的轮询特性，系统不提供任何旋转锁的实现，但是您可以在特定的情况下轻松地实现它们。有关在内核中实现自旋锁的信息,请参阅[Kernel Programming Guide](https://developer.apple.com/library/archive/documentation/Darwin/Conceptual/KernelProgramming/About/About.html#//apple_ref/doc/uid/TP30000905) |
| Double-checked lock(双重检查锁) | 双重检查锁是一种尝试，通过在获取锁之前测试锁定条件来减少获取锁的开销。由于双重检查锁可能不安全，系统不提供显式支持，因此不鼓励使用双重检查锁。 |

> 注意:大多数类型的锁也包含一个内存屏障，以确保在进入临界区之前，任何加载和存储指令都已完成。

有关如何使用锁的信息，请参见[Using Locks](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/ThreadSafety/ThreadSafety.html#//apple_ref/doc/uid/10000057i-CH8-SW16)。

## 条件(Conditions)

**条件是另一种类型的信号量，它允许线程在某个条件为真时相互发出信号。条件通常用于指示资源的可用性或确保任务按照特定的顺序执行**。当线程测试一个条件时，它会阻塞，除非该条件已经为真。它将保持阻塞状态，直到其他线程显式地更改并发出信号。**条件和互斥锁的区别在于可以允许多个线程同时访问条件**。条件就像是看门人，只有满足设定的标准才让不同的线程访问。

使用条件的一种方法是管理待处理事件池。当事件队列中有事件时，事件队列将使用条件变量来通知等待线程。如果一个事件到达，则队列将适当地发出条件信号。如果一个线程已经在等待，它将被唤醒，然后从队列中拉出事件并处理它。如果两个事件大约在同一时间进入队列，队列将发出两次条件信号，以唤醒两个线程。

系统提供多种不同技术实现条件。但是，条件的正确实现需要仔细编码，所以在您自己的代码中使用条件之前，应该先看看使用条件的示例[Using Conditions](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/ThreadSafety/ThreadSafety.html#//apple_ref/doc/uid/10000057i-CH8-SW4)。

## 执行Selector例程

Cocoa应用程序可以很方便地以同步的方式将消息传递给单个线程。NSObject类声明了在应用程序的一个活动线程上执行选择器的方法。这些方法让您的线程异步交付消息，并保证目标线程将同步执行这些消息。例如，可以使用执行Selector消息将分布式计算的结果传递给应用程序的主线程或指定的辅助线程。

有关执行Selector例程的摘要和有关如何使用它们的更多信息，请参见[Cocoa Perform Selector Sources](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW44)

# 同步开销与性能

同步有助于确保代码的正确性，但这是以牺牲性能为代价的。使用同步工具会带来延迟，即使在没有竞争的情况下也是如此。锁和原子操作通常涉及使用内存屏障和内核级同步，以确保代码得到适当的保护。如果存在竞争锁，那么您的线程可能会阻塞并经历更大的延迟。

表4-2列出了在无争用情况下与互斥锁和原子操作相关的一些大致开销。这些测量代表了数千个样本的平均时间。但是，与线程创建时间一样，获取互斥锁的时间(即使在无竞争的情况下)可能会根据处理器负载、计算机速度以及可用的系统和程序内存数量有很大差异。

表4-2 互斥和原子操作开销

| 项             | 大致开销     | 描述                                                         |
| -------------- | ------------ | ------------------------------------------------------------ |
| 互斥锁获取时间 | 大约0.2微秒  | 这是无争用情况下的锁获取时间。如果锁被另一个线程持有，那么获取时间可能会大得多。这些数据是通过分析在运行OS X v10.5、2ghz双核处理器和1gb RAM的基于intel的iMac上获取互斥锁时生成的平均值和中值来确定的。 |
| 原子比较和交换 | 大约0.05微秒 | 这是无争用情况下的比较和交换时间。这些数据是通过分析操作的平均值和中值来确定的，是在运行OS X v10.5的基于intel的iMac上生成的，iMac拥有2ghz Core Duo处理器和1gb RAM。 |

在设计并发任务时，正确性始终是最重要的因素，但是您还应该考虑性能因素。在多个线程下正确执行的代码，但比在单个线程上运行的相同代码慢，这算不上什么改进。

如果要对现有的单线程应用程序进行改造，则应该始终采取一组关键任务性能的基准度量。在添加额外的线程之后，您应该对这些相同的任务进行新的度量，并比较多线程情况和单线程情况的性能。如果在调优代码之后，线程并没有提高性能，那么您可能需要重新考虑特定的实现或线程的使用。

有关性能和收集性能指标的工具的信息，请参见 *[Performance Overview](https://developer.apple.com/library/archive/documentation/Performance/Conceptual/PerformanceOverview/Introduction/Introduction.html#//apple_ref/doc/uid/TP40001410)*。有关锁和原子操作成本的具体信息，请参见[Thread Costs](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/CreatingThreads/CreatingThreads.html#//apple_ref/doc/uid/10000057i-CH15-SW7)。

# 线程安全与信号



# 线程安全设计技巧



# 使用原子操作



# 使用锁



# 使用条件(Conditions)




# 进程

进程本质上是正在执行的一个程序。与每个进程相关的是**地址空间**（address space），这是从某个最小值的存储位置（通常是零）到某个最大值的存储位置的列表。在这个地址空间中，进程可以进行读写。该地址空间中存放有可执行程序、程序的数据以及程序的堆栈。与每个进程相关的还有资源集，通常包括寄存器（含有程序计数器和堆栈指针）、打开文件的清单、突出的报警、有关进程清单，以及运行该程序所需要的所有其他信息。进程基本上是容纳运行一个程序所需要所有信息的容器

一个进程暂时被挂起后，在随后的某个时刻里，该进程再次启动时的状态必须与先前暂停时完全相同,这就意味着在挂起时该进程的所有信息都要保存下来。例如，为了同时读入信息，进程打开了若干文件。与每个被打开文件有关的是指向当前位置的指针(即下一个将读出的字节或记录)。在一个进程暂时被挂起时，所有这些指针都必须保存起来，这样在该进程重新启动之后所执行的读调用才能读到正确的数据。在许多操作系统中，与一个进程有关的所有信息，除了该进程自身地址空间的内容以外，均存放在操作系统的一张表中，称为**进程表**（process table），进程表是数组(或链表)结构，当前存在的每个进程都要占用其中一项

所以，一个（挂起的）进程包括：进程的地址空间（往往称作磁芯映像，core image，纪念过去使用的磁芯存储器），以及对应的进程表项（其中包括寄存器以及稍后重启动该进程所需要的许多其他信息）

与进程管理有关的最关键的系统调用是那些进行进程创建和进程终止的系统调用。考虑一个典型的例子。有一个称为命令解释器（command interpreter）或shell的进程从终端上读命令。此时，用户刚键入一条命令要求编译一个程序。shell必须先创建一个新进程来执行编译程序。当执行编译的进程结束时，它执行一个系统调用来终止自己

若一个进程能够创建一个或多个进程（称为**子进程**），而且这些进程又可以创建子进程，则很容易得到进程树。**合作完成某些作业的相关进程经常需要彼此通信以便同步它们的行为。这种通信称为进程间通信（interprocess communication）**

系统管理器授权每个进程使用一个给定的**UID**(User IDentification)。每个被启动的进程都有一个
启动该进程的用户UID。**子进程拥有与父进程一样的UID**。用户可以是某个组的成员，每个组也有一个
 **GID** (Group IDentification).

# 地址空间

每台计算机都有一些主存，用来保存正在执行的程序。在非常简单的操作系统中，内存中一次只能有一个程序。如果要运行第二个程序，第一个程序就必须被移出内存，再把第二个程序装入内存。
较复杂的操作系统允许在内存中同时运行多道程序。为了避免它们互相干扰（包括操作系统），需要有某种保护机制。虽然这种机制必然是硬件形式的，但是由操作系统掌控

上述的观点涉及对计算机主存的管理和保护。另一种不同但是同样重要并与存储器有关的内容，是管理进程的地址空间。通常，每个进程有一些可以使用的地址集合，典型值从0开始直到某个最大值。在最简单的情形下，一个进程可拥有的最大地址空间小于主存。在这种方式下，进程可以用满其地址空间，而且内存中也有足够的空间容纳该进程

但是，在许多32位或64位地址的计算机中，分别有2的32次方或2的64次方字节的地址空间。如果一个进程有比计算机拥有的主存还大的地址空间，而且该进程希望使用全部的内存，那怎么办呢？在早期的计算机中，这个进程只好"认命"了。现在，有了一种称为虚拟内存的技术，正如前面已经介绍过的，操作系统可以把部分地址空间装人主存，部分留在磁盘上，并且在需要时来回交换它们。**在本质上，操作系统创建了一个地址空间的抽象，作为进程可以引用地址的集合**。该地址空间与机器的物理内存解耦，可能大于也可能小于该物理空间。对地址空间和物理空间的管理组成了操作系统功能的一个重要部分。

# 文件



